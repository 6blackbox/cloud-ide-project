const express = require('express');const http = require('http');const { Server } = require('socket.io');const fs = require('fs');const path = require('path');const { spawn, execSync } = require('child_process');const httpProxy = require('http-proxy');const app = express();const server = http.createServer(app);const proxy = httpProxy.createProxyServer({});const activePorts = new Map();let portCounter = 3001;const io = new Server(server, {    cors: { origin: "http://localhost:3000", methods: ["GET", "POST"] }});app.use('/preview/:socketId', (req, res) => {    const socketId = req.params.socketId;    const targetPort = activePorts.get(socketId);    if (!targetPort) {        return res.status(404).send(`            <body style="background:#111; color:#555; font-family:monospace; display:flex; justify-content:center; align-items:center; height:100vh;">                <h2>No server running for this session.</h2>            </body>        `);    }    proxy.web(req, res, { target: `http://localhost:${targetPort}` }, (err) => {    });});const extractPackages = (code) => {    const regex = /(?:require\(|from\s+)['"]([^'./][^'"]*)['"]/g;    const packages = new Set();    let match;    while ((match = regex.exec(code)) !== null) packages.add(match[1]);    return Array.from(packages);};const safeCleanup = (dirPath) => {    try {        if (fs.existsSync(dirPath)) {            fs.rmSync(dirPath, { recursive: true, force: true });        }    } catch (err) {        console.log(`[Warning] Could not clean dir immediately: ${err.message}`);    }};io.on('connection', (socket) => {    console.log('User connected:', socket.id);    const userPort = portCounter++;    activePorts.set(socket.id, userPort);    socket.emit('system-info', { port: userPort });    let activeProcess = null;    socket.on('run-code', async (files) => {        const tempDir = path.join(__dirname, 'temp', socket.id);        if (activeProcess) {            try {                activeProcess.kill();             } catch (e) {                console.log('Error killing process:', e.message);            }            activeProcess = null;        }        await new Promise(resolve => setTimeout(resolve, 100));        safeCleanup(tempDir);        if (!fs.existsSync(tempDir)) {             fs.mkdirSync(tempDir, { recursive: true });        }        try {            const entryPoint = path.join(tempDir, 'index.js');            let allPackages = [];            Object.keys(files).forEach(filename => {                const content = files[filename].value;                fs.writeFileSync(path.join(tempDir, filename), content);                allPackages = [...allPackages, ...extractPackages(content)];            });            const builtIns = ['fs', 'path', 'http', 'os', 'crypto', 'util', 'events', 'express'];            const dependencies = [...new Set(allPackages)].filter(pkg => !builtIns.includes(pkg));            if (dependencies.length > 0) {                socket.emit('terminal-output', `\x1b[33m[System] Installing: ${dependencies.join(', ')}...\r\n\x1b[0m`);                try {                    if (!fs.existsSync(path.join(tempDir, 'node_modules'))) {                        execSync('npm init -y', { cwd: tempDir, stdio: 'ignore' });                        execSync(`npm install ${dependencies.join(' ')}`, { cwd: tempDir, stdio: 'ignore' });                    }                } catch (e) {                    socket.emit('terminal-output', `\x1b[31m[Error] Failed to install packages.\x1b[0m\r\n`);                }            }            if (!fs.existsSync(entryPoint)) {                socket.emit('terminal-output', '\x1b[31m[Error] index.js not found.\x1b[0m\r\n');                return;            }            const child = spawn('node', ['index.js'], {                 cwd: tempDir,                env: { ...process.env, PORT: userPort },            });            activeProcess = child;            child.stdout.on('data', (data) => socket.emit('terminal-output', data.toString()));            child.stderr.on('data', (data) => socket.emit('terminal-output', `\x1b[31m${data.toString()}\x1b[0m`));            child.on('close', (code) => {                socket.emit('terminal-output', `\r\n\x1b[2m[Process exited with code ${code}]\x1b[0m\r\n`);            });        } catch (error) {            socket.emit('terminal-output', `\x1b[31m[System Error] ${error.message}\x1b[0m\r\n`);        }    });    socket.on('disconnect', () => {        activePorts.delete(socket.id);        if (activeProcess) {             try { activeProcess.kill(); } catch(e) {}        }    });});const PORT = 4000;server.listen(PORT, () => console.log(`Server running on http://localhost:${PORT}`));